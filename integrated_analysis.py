#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Oct 18 17:41:10 2024

@author: masullo
"""

import numpy as np
import glob
import os
import pandas as pd
import matplotlib.pyplot as plt
import configparser
from timeit import default_timer as timer

from sklearn.neighbors import NearestNeighbors
from scipy.spatial.distance import pdist


abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

from Functions import io
from Functions import dbscan

plt.close('all')

"""
===============================================================================
Load experimental data
===============================================================================
"""

# 240617_HMEC ManNAz
path = r'/Volumes/pool-miblab/users/masullo/z_raw/GlycoRESI/240617_HMEC/RESI_ManNAz/workflow_analysis/00_cluster_241009-1223/00_cluster_aggregation_241009-1223/04_save_datasets_aggregated/'

filename = r'target_picked'

px = 130

# create subfolder for results
results_path = os.path.join(path, 'integrated_results/')
try:
    os.mkdir(results_path)

except OSError:
    pass

filepath = path + filename 
df_exp = pd.read_hdf(filepath + '.hdf5', key = 'locs')

N = df_exp.shape[0] # total number of sugars
print('Total number of sugars:', N)

"""
===============================================================================
Simulation of CSR data
===============================================================================
"""

picked_area = io.extract_total_picked_area(path + filename + '.yaml')
picked_area = np.around(picked_area, 4)

if picked_area is not None:
    print(f"Total Picked Area (um^2): {picked_area}")
else:
    print("The 'Total Picked Area (Î¼m^2)' parameter was not found.")

obs_density = N / picked_area

N_sim = int(1e6) # this parameter controls the resolution of the simulation
w = np.sqrt(N/obs_density) 
h = w

# simple CSR model
pos_sim = np.array([np.random.uniform(0, w, N), 
                    np.random.uniform(0, h, N)]).T

pos_sim = pos_sim * 1e3 # in nm

# =============================================================================
# save positions of the simulated molecules as a Picasso compatible file
# =============================================================================

filename_csr = 'simulated_CSR_'

width = w/px
height = h/px

info_csr = {}
info_csr["Generated by"] = "CSR simulation to compare with glycans data"
info_csr["Width"] = width # pixel 
info_csr["Height"] = height # pixel
info_csr["Pixelsize"] = px # in nm

io.save_pos(results_path, filename_csr, width, height, pos_sim/px, [info_csr])

df_sim = pd.read_hdf(results_path + filename_csr + '.hdf5', key = 'locs')

"""
===============================================================================
Analysis pipeline
===============================================================================
"""


for i, df in enumerate([df_exp, df_sim]):
    
    print(i)
    print(df)


"""
===============================================================================
Parameters for DBSCAN
===============================================================================
"""

epsilon_nm = 10
epsilon_px = epsilon_nm/px
minpts = 2

"""
===============================================================================
DBSCAN
===============================================================================
"""
# Info to be added to dbscan yaml filename
# info_db = {
#     'Generated by': 'DBSCAN',
#     'epsilon': epsilon_px,
#     'minpts': minpts
#     }

db_clusters = dbscan.dbscan_f(df, epsilon_px, minpts)

info = io.load_info(filepath + '.yaml')

# save locs in dbscan cluster with colorcoding = protein ID
dbscan_filename = '%s_dbscan_%s_%d.hdf5' % (filename, str(epsilon_nm), minpts)
io.save_locs(results_path + dbscan_filename, db_clusters, info)


"""
===============================================================================
Analysis on each cluster (sugar counts, max distance, etc)
===============================================================================
"""

nclusters = db_clusters['group'].max()

cluster_size = []
maxdist_list = []

for i in range(nclusters):
    
    cluster = db_clusters[db_clusters['group'] == i]
    
    sugars = np.array([cluster['x'], 
                       cluster['y']])
                
    nsugars = (sugars.shape[1])
    
    cluster_size.append(nsugars)
    
    if nsugars > 2:
    
        pairwise_distances = pdist(sugars.T)
        maxdist = np.max(pairwise_distances)
        
        maxdist_list.append(maxdist)

"""
===============================================================================
0. Sugar count per cluster
===============================================================================
"""

nbins_0 = np.arange(0, 12, 1)

counts, bin_edges = np.histogram(cluster_size, bins=nbins_0, density=False)

bin_centers = (bin_edges[:-1] + bin_edges[1:])/2

fig_0, ax_0 = plt.subplots()

ax_0.bar(bin_edges[:-1] -0.2, counts, edgecolor='black', linewidth=0.2, 
            width=0.4, alpha=0.8, color='#00A7E1', label='Data')

print('Number of clustered sugars:', np.array(cluster_size).sum())

"""
===============================================================================
1. Analysis of max dist within a cluster
===============================================================================
"""

nbins_1 = np.arange(0, 100, 1)

maxdist_list = np.array(maxdist_list) * px

fig_1, ax_1 = plt.subplots()

ax_1.hist(maxdist_list, bins=nbins_1, density=True, alpha=0.5)


"""
===============================================================================
2. NND calculation for experimental data
===============================================================================
"""

# parameters for the NND analysis
binsize = 1
maxdist = 1000

fsize = (10, 10)
msize = 50

x_0 = df.x * px # in nm
y_0 = df.y * px # in nm

pos_exp_0 = np.array([x_0, y_0]).T

# find nearest neighbours from biomolecule 0 to biomolecule 1 (exp data), in this case is the same biomolecule (e.g. ManNAz, GalNAz)
nbrs = NearestNeighbors(n_neighbors=5).fit(pos_exp_0) 
_distances_exp, _indices_exp = nbrs.kneighbors(pos_exp_0) # get distances and indices

distances_exp = {}
freqs_exp = {}
bin_centers_exp = {}

for i in range(4):
    
    key = str(i+1) + 'nn'
    distances_exp[key] = _distances_exp[:, i+1] # get the first neighbour distances (0 for hetero, 1 for homo in the second coord)

    bins = np.arange(0, maxdist, binsize)
    freqs_exp[key], bin_edges = np.histogram(distances_exp[key], bins=bins, density=True)

    bin_centers_exp[key] = (bin_edges[:-1] + bin_edges[1:])/2

# =============================================================================
# Plot of experimental NNDs
# =============================================================================

fig_2, ax_2 = plt.subplots()

colors = ['#2880C4', '#97D8C4', '#F4B942', '#363636']

ax_2.set_xlim(0, 100)
ax_2.set_ylim(0, 0.06)

ax_2.set_xlabel('K-th NND (nm)')
ax_2.set_ylabel('Counts')

ax_2.set_box_aspect(1)

binsize_exp = 0.5
bins_exp = np.arange(0, maxdist, binsize_exp)

for i in range(4):
    
    key = str(i+1) + 'nn'

    counts, bin_edges, _ = ax_2.hist(distances_exp[key], bins=bins_exp, 
                                    edgecolor='black', linewidth=0.1, alpha=0.5, 
                                    density=True, color=colors[i], label=key)
    